Flexo
=====

## Инструкция по установке
* Перед запуском провести установку зависимостей `npm install`
* Для запуска требуется установка `nodeunit` через `npm -g i nodeunit`
* Перед запуском провести установку зависимостей `npm install` (требуется `f0.argstype` и `f0.rabbit`) 
* Для тестов с настоящим `rabbit`, надо в тесте закомментировать строку `mock = true;`
* Перед запуском с настоящим `rabbit` следует очистить коллекции `test` и `test_join`
* Запуск теста: `nodeunit test/index.js`
* Очистка mongo и redis: `mongo --eval 'db.test.remove(); db.test_join.remove();' && redis-cli FLUSHALL`



## TODO
* поддержка уникальных индексов, предотвращающих создание дублирующих документов;
* поддержка вычисляемых полей.



## Схемы `flexo`
```js
// название схемы
// под этим именем схема попадает в глобальный объект
exports.name: 'test';


// корень
// содержит изменяемые поля
// `_id`, `tsCreate`, `tsUpdate` добавляются автоматически
// ключ - название поля
// значение - объект со свойствами поля:
// * type - тип в БД (типы данных описаны ниже)
// * [subtype] - для типа objarray содержит схему вложенных объектов вида `{ fieldName: { type: 'typeName' } }` 
// * [from] - содержит название коллекции на которую ссылается поле
// * [link] - содержит название пути, который должен быть встроен в документы текущей коллекции
// * [weight] - определяет, производить ли взвешивание поля, содержит `true` или `false`
// * [includeWeight] - указывает на необходимость втянуть веса полей из другой схемы, содержит массив названий схем `[ 'scheme1', 'scheme2' ]`
// * [title] - название поля для админки
// * [description] - расширенное описание поля для админки
exports.root: {
    name: { type: 'str' },
    inn: { type: 'numeric' },
    index: { type: 'int' },
    comment: { type: 'str' },
    join_id: { type: 'id' }, // автоматически обязательное поле из-за джойна
    array_of_id: { type: 'id', from: 'test_join', link: 'array_of_id' } // может быть пустым
};


// присоединения
// определяют неизменяемые поля докуемнта, значения которых втягиваются из других документов
exports.join: {
    test_join: { // название схемы
        rename: 'tj', // префикс присоединяемых полей; надо удостовериться, работает ли этот механизм
        fields: [ 'name', 'inn', 'comment' ], // перечень присоединяемых полей; `_id` добавляется автоматически
        depend: [ 'root', 'join_id' ] // объявление правила, определяющего _id присоединяемого документа: название группы/корень, название поля группы/корня
    }
};


// пользовательские функции (хуки), выполняющиеся до/после операции создания/модификации документа
// каждый хук вызывается с объектом в переменной this, у которого есть следующие ключи:
// * db - объект, контейнер методов `flexo` (find, aggregate, insert, modify, delete)
// * query - объект, содержит элемент массива запросов
// * [result] - объект, доступен в запросах `after`, содержит элемент массива результатов
// * lib - объект
// * * async - объект, библиотека `async`
// * * argstype - объект, библиотека `argstype`
//
// `callback` хуков `before` должны вызываться с 2 параметрами: ошибка, измененный или исходный объект `this.request`
// каждый хук из массива должен отработать за 10 секунд (по умолчанию), иначе на запрос будет возвращена ошибка
exports.before: { // на данный момент может содержать только `insert`, `modify`
    insert: [ // функции в массиве запускаются через `async.parallel`
        function( callback ) { return callback( null, this.request ); }
    ],
    modify: [
        function( callback ) { return callback( null, this.request ); }
    ]
};
exports.after: { // может содержать только `insert`, `modify`
    insert: [
        function( callback ) { return callback( null, true ); }
    ],
    modify: [
        function( callback ) { return callback( null, true ); }
    ]
};


// НЕ РАБОТАЕТ
// уникальные значения
// содержит индексы, которые должны быть уникальными на базу
// индекс может быть по 1 полю или более
// индекс может включать в себя поля только из корневого блока
exports.unique: [
    [ 'inn' ]
];
```



## Типы данных
Если в запросе на создание/модификацию в поле содержится пустая строка, будет использовано значение по умолчанию.  
Поддерживаемые типы:
* `_id` - технический тип, можно использовать /только/ для поля `_id`
* `array` - технический тип, не следует его использовать, массив с произвольным содержимым
* `id` - массив `_id`, только этот тип следует использовать для связи между документами 
* `str` - строка
* `strs` - массив строк
* `words` - строка разбитая на слова по символам находящимся регулярным выражением `/[^a-zA-Zа-яА-Я0-9]/gi`
* `int` - целое число
* `float` - число с плавающей запятой и потерей точности
* `bool` - логическое значение `true` или `false`
* `money` - денежный тип с 2 знаками после запятой (в базе хранится как число умноженное на 100, пиведенное к int)
* `numeric` - строка цифр
* `phone` - телефонный номер, в базе строка `7xxxxxxxxxx`, пользователь вводит и видит `(xxx)xxx-xx-xx`
* `objarray` - массив объектов, для этого типа обязательно свойство `subtype`



## Поиск по строкам
Для поиска по строковым типам может быть использован управляющий символ, предварающий поисковую строку.
В файле [lib/flexo/re-opcode.js](//github.com/f0-soft/flexo/blob/master/lib/flexo/re-opcode.js) функция `code` производит создание управляющего символа из объекта параметров.

При поиске по типу `str` и `strs`:
* нет управляющего символа - к базе делается запрос вида `{ key: 'value' }`
* есть управляющий символ - к базе делается запрос вида `{ key: /^value$/i }` с соответствующими опциями

При поиске по типу `words`:
* нет управляющего символа - к базе делается запрос вида `{ key: { $in: [ /^value1/, /^value2/, ... ] } }`
* есть управляющий символ - к базе делается запрос вида `{ key: /^value$/i }` с соответствующими опциями

Пример формирования запроса с управляющим символом
```
// функция из файла lib/flexo/re-opcode.js
var opcodes = { '^': 1, '$': 2, 'i': 4, 'm': 8, 's': 16 };
var skip = 4096;
function code( options ) {
	var res = skip;
	var keys = Object.keys( options );
	for ( var i = 0; i < keys.length; i += 1 ) {
		if ( opcodes[keys[i]] !== undefined ) {
			res += opcodes[keys[i]];
		}
	}
	return String.fromCharCode( res );
}

var searchString = 'Ромашка';
var searchOptions = {
    '^': true, // от начала строки
    '$': true, // до конца строки
    'i': true  // без учета регистра
}

var requestString = code( searchOptions ) + searchString;
```



## init( options, callback )
Производит инициализацию библиотеки.

Параметры:
* `options` - объект
	* `storage` - объект, содержит функции работы с хранилищем (`find`, `insert`, `modify`, `delete`)
	* `schemes` - объект, содержит доступные схемы со справочниками
	* `hook_timeout` - число, таймаут выполнения хуков в секундах
* `callback( error, collection )` - функция
	* `collection` - объект, содержит функции работы с библиотекой: `find`, `insert`, `modify`, `delete`

Пример `schemes`
```
var schemes = {
	orders: {
		scheme: require( './test.schemes/orders.js' ),
		dict: {
			// все поля документа, влючая системные _id, tsCreate, tsUpdate
			all: ['_id', 'tsCreate', 'tsUpdate', 'number', 'comments', 'services'],

			// изменяемые поля корневого блока
			mutable: ['number', 'comments', 'services'],

			// поля корневого блока от которых зависят джойны
			joinProperties: [],

			// названия схем присоединяемых блоков
			joins: [],

			types: { // справочник типов всех полей (значения полей из схемы), type обязателен
				_id: { type: 'id' },
				tsCreate: { type: 'int' },
				tsUpdate: { type: 'int' },
				number: { type: 'str' },
				comments: { type: 'str' },
				services: { type: 'ids', from: 'test_join' }
			}
		}
	},
	test: {
		scheme: require( './test.schemes/test.js' ),
		dict: {
			// все поля документа, влючая системные _id, tsCreate, tsUpdate
			all: ['_id', 'tsCreate', 'tsUpdate', 'name', 'inn', 'comment', 'join_id', 'array_of_id', 'test_join__id', 'test_join_name', 'test_join_inn', 'test_join_comment'],

			// изменяемые поля корневого блока
			mutable: ['name', 'inn', 'comment', 'join_id', 'array_of_id'],

			// поля корневого блока от которых зависят джойны
			joinProperties: ['join_id'],

			// названия схем присоединяемых блоков
			joins: ['test_join'],

			types: { // справочник типов всех полей (значения полей из схемы), type обязателен
				_id: { type: 'id' },
				tsCreate: { type: 'int' },
				tsUpdate: { type: 'int' },
				name: { type: 'words' },
				inn: { type: 'numeric' },
				comment: { type: 'str' },
				join_id: { type: 'id' },
				array_of_id: { type: 'ids', from: 'test_join' },
				test_join__id: { type: 'id' },
				test_join_name: { type: 'str' },
				test_join_inn: { type: 'str' },
				test_join_comment: { type: 'str' }
			}
		}
	}
};

```



## container
Контейнер функций работы с проинициализированной библиотекой `Flexo`.
Содержит методы, предоставляющие доступ к документам по заданной схеме

Документы включают в себя:
* собственные поля;
* присоединенные из иных документов поля.



### container.find( request, callback )
Осуществляет поиск документов в хранилище.
Возвращает удовлетворяющие запросу документы (и их количество).

Параметры:
* `request` - объект
    * `name` - строка, содержит название схемы
    * `fields` - массив, содержит названия полей, с которыми надо вернуть документы
    * `query` - объект, поисковый запрос Mongo
    * `[options]` - объект
        * `[count]` - логическое, опция запроса количества документов удовлетворяющих запросу
        * `[limit]` - число, ограничение количества результатов поиска
        * `[skip]` - число, смещение ограничения количества результатов поиска
        * `[sortData]` - объект
        * `[sort]` - массив, содержит 3 элемента или массив объектов `sort`, правило сортировки Mongo
            * `collection` - строка, название коллекции, содержащей поле, по которому совершается сортировка
            * `linkField` - строка, содержит название поля, содержащего связь с другой коллекцией или пустая строка
            * `sort` - объект, содержит поля и направления сортировки
* `callback( error, data )` - функция
    * `data` - объект
	    * `result` - массив, содержит объекты документов
	    * `idFields` - массив, названия полей, у которых тип `id`, в которых может содержаться путь
	    * `[count]` - число, общее количество удовлетворяющих запросу документов
	    * `[dep]` - число, наличие ссылок на документ, возвращается при поиске документа по `_id`
	    * `[sortData]` - строка
	    
Пример запроса с сортировкой
```
// схема bill
exports.name = 'bill';
exports.root = {
    sum: { type: 'float' },
    manager_id: { type: 'id', from: 'manager', includeWeight: [ 'manager' ] }
};

// схема manager
exports.name = 'manager';
exports.root = {
    name: { type: 'str', weight: true }
};

// поисковый запрос
flexo.find({
    name: 'bill',
    fields: [ 'sum' ],
    query: {},
    options: {
        sort: [
            'manager',
            'manager_id',
            { name: 1 }
        ]
    }
}, next);
```



### container.aggregate( request, callback )
Производит аггреацию, вызывает аггрегацию Rabbit.
 
Параметры:
* `request` - объект
    * `name` - строка, содержит название схемы
    * `pipeline` - массив, содержит последовательность агрегации в естественном виде
* `callback( error, documents )` - функция
    * `documents` - массив, содержит результаты агрегации



### container.insert( request, callback )
Проверяет полученные документы, присоединяет к ним зависимые блоки, сохраняет результирующие документы в хранилище.
Возвращает созданные документы.

Документ может содержать только поля, относящиеся к корневому блоку документа.
Документ не может содержать служебные поля: `_id`, `tsCreate`, `tsUpdate`.
Для документа обязательными являются поля, по которым осуществляется присоединение зависимых блоков.
Параметры документа `tsCreate` и `tsUpdate` создаются на уровне метода.

Параметры:
* `request` - объект
    * `scheme` - строка, содержит название схемы
    * `fields` - массив, содержит названия полей, с которыми надо вернуть документы
    * `query` - массив
        * `*` - объект, содержит поля нового документа
    * `[options]` - объект
* `callback( error, data )` - функция
    * `data` - объект
	    * `result` - массив, содержит объекты сохраненных документов
	    * `idFields` - массив, названия полей, у которых тип `id`, в которых может содержаться путь



### container.modify( request, callback )
Производит обновление параметров документов в хранилище.
Возвращает массив измененных документов, сокращенных до `_id`, `tsUpdate`.

Параметры:
* `request` - объект
    * `name` - строка, содержит название схемы
    * `query` - массив объектов `query`
        * `*` - объект
	        * `selector` - объект, поисковый запрос Mongo, обязательно должен содержать поля `_id` и `tsUpdate`
	        * `properties` - объект новых значений
    * `[options]` - объект
* `callback( error, documents )` - функция
	* `documents` - массив, содержит объекты документов, сокращенных до `_id`, `tsUpdate`



### container.delete( request, callback )
Удаляет заданные документы в хранилище.
Возвращает массив удаленных документов, сокращенных до `_id`.

Параметры:
* `request` - объект
    * `name` - строка, содержит название схемы
    * `query` - массив
	    * `*` - объект, поисковый запрос Mongo, обязательно должен содержать поля `_id` и `tsUpdate`
    * `[options]` - объект
* `callback( error, documents )` - функция
	* `documents` - массив, содержит объекты удаленных документов, сокращенные до `_id`



## container.groupCount( request, percentCb, callback )
Подсчет количества документов по группам.    
Например, счета можно разбить на группы по степени оплаченности.
Сопоставляемые коллекции должны быть соседними

Параметры:
* `request` - объект
    * `parent` - объект, содержит информацию по родительской коллекции
        * `coll` - строка, название коллекции
        * `field_sum` - строка, поле сравнения значений
        * `field_link` - строка, поле связи, у родительских документов `_id`
        * `selector` - объект, селектор rabbit
    * `child` - объект, содержит информацию по дочерней коллекции
        * `coll` - строка, название коллекции
        * `field_sum` - строка, поле сравнения значений
        * `field_link` - строка, поле связи, у дочерних документов обычно что-то вроде `parent_id`
        * `selector` - объект, селектор rabbit
    * `groups` - массив
        * `*` - объект, содержит определение группы
* `percentCb( percent )` - функция
    * `percent` - число, процент выполнения запроса, целое от 0 до 100
* `callback( error, result )` - функция
    * `result` - массив
        * `*` - объект, элемент результата группировки
            * `count` - число
            * `parentSum` - число, сумма полей родительских документов, относящихся к заданной группе
            * `childSum` - число, сумма полей дочерних документов, относящихся к заданной группе
            * `parents` - массив, содержит количество связанных родительских элементов по уровням, составляется посредством разбора пути
            
Пример запроса на группировку всех счетов по степени оплаченности всеми поступлениями
```
var request = {};

request.parent = {
    coll: 'bills',
    field_sum: 'sum',
    field_link: '_id',
    selector: {}
};

request.child = {
    coll: 'bank',
    field_sum: 'sum',
    field_link: 'bill_id',
    selector: {}
};

request.groups = [
    { $gte: 100 }, // оплата на 100% и более
    { $gte: 66, $lt: 100 }, // оплата на 66-100%
    { $gte: 33, $lt: 66 }, // оплата на 33-66%
    { $gt: 0, $lt: 33 }, // оплата на 0-33%
    { $eq: 0 } // счета без оплаты
];
```

Пример ответа на приведенный выше запрос
```
var result = [
    { count: 2246, parentSum: 306950900.86, childSum: 484736888, // оплата более, чем на 100%
        // последний элемент массива - самый близкий уровень уровень
        // первый элемент массива - самый далекий уровень
        parents: [
            672, // менеджеры
            1148, // компании
            1749, // договоры
    ] },
    { count: 1163, parentSum: 167469907.11, childSum: 141175168, // оплата на 100% 
        parents: [ 577, 825, 1020 ] },
    { count: 777, parentSum: 116827703.72, childSum: 59539508, // оплата на 75-100% 
        parents: [ 474, 621, 711 ] },
    { count: 542, parentSum: 89374340.74, childSum: 15800005, // оплата на 0-75% 
        parents: [ 380, 458, 512 ] },
    { count: 312, parentSum: 38983792.9, childSum: 0, // счета без оплаты 
        parents: [ 0, 0, 0 ] }
];
```

Поля `parentSum` и `childSum` возвращаются трансформированными для пользователя.  
Например, если суммируется поле денег, будет возвращено значение типа `float` с копейками после запятой.  
Длина массива `parents` зависит от того, насколько длинный путь 
